<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    java | InJune&#39;s Blog
</title>
<link rel="shortcut icon" href="https://zhch602.github.io/favicon.ico?v=1573799572364">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://zhch602.github.io/styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://zhch602.github.io/media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-139615634-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }
        gtag('js', new Date());

        gtag('config', 'UA-139615634-1');
    </script>
    
</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://zhch602.github.io">
                <img class="avatar" src="https://zhch602.github.io/images/avatar.png?v=1573799572364" alt="">
            </a>
            <div class="site-title">
                <h1>
                    InJune&#39;s Blog
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-container main-container">
                <div id="content" class="main-container-left">
                    
    <div class="i-card">
        <b>标签：#
        java</b>
    </div>
    
        
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://zhch602.github.io/post/qing-liang-ji-fen-bu-shi-rpc-kuang-jia">
                        轻量级分布式 RPC 框架
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-05-06</time>
                    
                        <a href="https://zhch602.github.io/tag/imQ_OK1Mz" class="post-tag i-tag
                            i-tag-other_1">
            #java
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            RPC，即 Remote Procedure Call（远程过程调用），说得通俗一点就是：调用远程计算机上的服务，就像调用本地服务一样。
RPC 可基于 HTTP 或 TCP 协议，Web Service 就是基于 HTTP 协议的 RPC，它具有良好的跨平台性，但其性能却不如基于 TCP 协议的 RPC。会两方面会直接影响 RPC 的性能，一是传输方式，二是序列化。
众所周知，TCP 是传输层协议，HTTP 是应用层协议，而传输层较应用层更加底层，在数据传输方面，越底层越快，因此，在一般情况下，TCP 一定比 HTTP 快。就序列化而言，Java 提供了默认的序列化方式，但在高并发的情况下，这种方式将会带来一些性能上的瓶颈，于是市面上出现了一系列优秀的序列化框架，比如：Protobuf、Kryo、Hessian、Jackson 等，它们可以取代 Java 默认的序列化，从而提供更高效的性能。
为了支持高并发，传统的阻塞式 IO 显然不太合适，因此我们需要异步的 IO，即 NIO。Java 提供了 NIO 的解决方案，Java 7 也提供了更优秀的 NIO.2 支持，用 Java 实现 NIO 并不是遥不可及的事情，只是需要我们熟悉 NIO 的技术细节。
我们需要将服务部署在分布式环境下的不同节点上，通过服务注册的方式，让客户端来自动发现当前可用的服务，并调用这些服务。这需要一种服务注册表（Service Registry）的组件，让它来注册分布式环境下所有的服务地址（包括：主机名与端口号）。
应用、服务、服务注册表之间的关系见下图：

每台 Server 上可发布多个 Service，这些 Service 共用一个 host 与 port，在分布式环境下会提供 Server 共同对外提供 Service。此外，为防止 Service Registry 出现单点故障，因此需要将其搭建为集群环境。
本文将为您揭晓开发轻量级分布式 RPC 框架的具体过程，该框架基于 TCP 协议，提供了 NIO 特性，提供高效的序列化方式，同时也具备服务注册与发现的能力。
根据以上技术需求，我们可使用如下技术选型：

Spring：它是最强大的依赖注入框架，也是业界的权威标准。
Netty：它使 NIO 编程更加容易，屏蔽了 Java 底层的 NIO 细节。
Protostuff：它基于 Protobuf 序列化框架，面向 POJO，无需编写 .proto 文件。
ZooKeeper：提供服务注册与发现功能，开发分布式系统的必备选择，同时它也具备天生的集群能力。

相关 Maven 依赖请见附录。
&amp;lt;!-- lang: java --&amp;gt;
public interface HelloService {

    String hello(String name);
}

将该接口放在独立的客户端 jar 包中，以供应用使用。
&amp;lt;!-- lang: java --&amp;gt;
@RpcService(HelloService.class) // 指定远程接口
public class HelloServiceImpl implements HelloService {

    @Override
    public String hello(String name) {
        return &amp;quot;Hello! &amp;quot; + name;
    }
}

使用RpcService注解定义在服务接口的实现类上，需要对该实现类指定远程接口，因为实现类可能会实现多个接口，一定要告诉框架哪个才是远程接口。
RpcService代码如下：
&amp;lt;!-- lang: java --&amp;gt;
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Component // 表明可被 Spring 扫描
public @interface RpcService {

    Class&amp;lt;?&amp;gt; value();
}

该注解具备 Spring 的Component注解的特性，可被 Spring 扫描。
该实现类放在服务端 jar 包中，该 jar 包还提供了一些服务端的配置文件与启动服务的引导程序。
服务端 Spring 配置文件名为spring.xml，内容如下：
&amp;lt;!-- lang: xml --&amp;gt;
&amp;lt;beans ...&amp;gt;
    &amp;lt;context:component-scan base-package=&amp;quot;com.xxx.rpc.sample.server&amp;quot;/&amp;gt;

    &amp;lt;context:property-placeholder location=&amp;quot;classpath:config.properties&amp;quot;/&amp;gt;

    &amp;lt;!-- 配置服务注册组件 --&amp;gt;
    &amp;lt;bean id=&amp;quot;serviceRegistry&amp;quot; class=&amp;quot;com.xxx.rpc.registry.ServiceRegistry&amp;quot;&amp;gt;
        &amp;lt;constructor-arg name=&amp;quot;registryAddress&amp;quot; value=&amp;quot;${registry.address}&amp;quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!-- 配置 RPC 服务器 --&amp;gt;
    &amp;lt;bean id=&amp;quot;rpcServer&amp;quot; class=&amp;quot;com.xxx.rpc.server.RpcServer&amp;quot;&amp;gt;
        &amp;lt;constructor-arg name=&amp;quot;serverAddress&amp;quot; value=&amp;quot;${server.address}&amp;quot;/&amp;gt;
        &amp;lt;constructor-arg name=&amp;quot;serviceRegistry&amp;quot; ref=&amp;quot;serviceRegistry&amp;quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;

具体的配置参数在config.properties文件中，内容如下：
&amp;lt;!-- lang: java --&amp;gt;
# ZooKeeper 服务器
registry.address=127.0.0.1:2181

# RPC 服务器
server.address=127.0.0.1:8000

以上配置表明：连接本地的 ZooKeeper 服务器，并在 8000 端口上发布 RPC 服务。
为了加载 Spring 配置文件来发布服务，只需编写一个引导程序即可：
&amp;lt;!-- lang: java --&amp;gt;
public class RpcBootstrap {

    public static void main(String[] args) {
        new ClassPathXmlApplicationContext(&amp;quot;spring.xml&amp;quot;);
    }
}

运行RpcBootstrap类的main方法即可启动服务端，但还有两个重要的组件尚未实现，它们分别是：ServiceRegistry与RpcServer，下文会给出具体实现细节。
使用 ZooKeeper 客户端可轻松实现服务注册功能，ServiceRegistry代码如下：
&amp;lt;!-- lang: java --&amp;gt;
public class ServiceRegistry {

    private static final Logger LOGGER = LoggerFactory.getLogger(ServiceRegistry.class);

    private CountDownLatch latch = new CountDownLatch(1);

    private String registryAddress;

    public ServiceRegistry(String registryAddress) {
        this.registryAddress = registryAddress;
    }

    public void register(String data) {
        if (data != null) {
            ZooKeeper zk = connectServer();
            if (zk != null) {
                createNode(zk, data);
            }
        }
    }

    private ZooKeeper connectServer() {
        ZooKeeper zk = null;
        try {
            zk = new ZooKeeper(registryAddress, Constant.ZK_SESSION_TIMEOUT, new Watcher() {
                @Override
                public void process(WatchedEvent event) {
                    if (event.getState() == Event.KeeperState.SyncConnected) {
                        latch.countDown();
                    }
                }
            });
            latch.await();
        } catch (IOException | InterruptedException e) {
            LOGGER.error(&amp;quot;&amp;quot;, e);
        }
        return zk;
    }

    private void createNode(ZooKeeper zk, String data) {
        try {
            byte[] bytes = data.getBytes();
            String path = zk.create(Constant.ZK_DATA_PATH, bytes, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);
            LOGGER.debug(&amp;quot;create zookeeper node ({} =&amp;gt; {})&amp;quot;, path, data);
        } catch (KeeperException | InterruptedException e) {
            LOGGER.error(&amp;quot;&amp;quot;, e);
        }
    }
}

其中，通过Constant配置了所有的常量：
&amp;lt;!-- lang: java --&amp;gt;
public interface Constant {

    int ZK_SESSION_TIMEOUT = 5000;

    String ZK_REGISTRY_PATH = &amp;quot;/registry&amp;quot;;
    String ZK_DATA_PATH = ZK_REGISTRY_PATH + &amp;quot;/data&amp;quot;;
}

注意：首先需要使用 ZooKeeper 客户端命令行创建/registry永久节点，用于存放所有的服务临时节点。
使用 Netty 可实现一个支持 NIO 的 RPC 服务器，需要使用ServiceRegistry注册服务地址，RpcServer代码如下：
&amp;lt;!-- lang: java --&amp;gt;
public class RpcServer implements ApplicationContextAware, InitializingBean {

    private static final Logger LOGGER = LoggerFactory.getLogger(RpcServer.class);

    private String serverAddress;
    private ServiceRegistry serviceRegistry;

    private Map&amp;lt;String, Object&amp;gt; handlerMap = new HashMap&amp;lt;&amp;gt;(); // 存放接口名与服务对象之间的映射关系

    public RpcServer(String serverAddress) {
        this.serverAddress = serverAddress;
    }

    public RpcServer(String serverAddress, ServiceRegistry serviceRegistry) {
        this.serverAddress = serverAddress;
        this.serviceRegistry = serviceRegistry;
    }

    @Override
    public void setApplicationContext(ApplicationContext ctx) throws BeansException {
        Map&amp;lt;String, Object&amp;gt; serviceBeanMap = ctx.getBeansWithAnnotation(RpcService.class); // 获取所有带有 RpcService 注解的 Spring Bean
        if (MapUtils.isNotEmpty(serviceBeanMap)) {
            for (Object serviceBean : serviceBeanMap.values()) {
                String interfaceName = serviceBean.getClass().getAnnotation(RpcService.class).value().getName();
                handlerMap.put(interfaceName, serviceBean);
            }
        }
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap bootstrap = new ServerBootstrap();
            bootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)
                .childHandler(new ChannelInitializer&amp;lt;SocketChannel&amp;gt;() {
                    @Override
                    public void initChannel(SocketChannel channel) throws Exception {
                        channel.pipeline()
                            .addLast(new RpcDecoder(RpcRequest.class)) // 将 RPC 请求进行解码（为了处理请求）
                            .addLast(new RpcEncoder(RpcResponse.class)) // 将 RPC 响应进行编码（为了返回响应）
                            .addLast(new RpcHandler(handlerMap)); // 处理 RPC 请求
                    }
                })
                .option(ChannelOption.SO_BACKLOG, 128)
                .childOption(ChannelOption.SO_KEEPALIVE, true);

            String[] array = serverAddress.split(&amp;quot;:&amp;quot;);
            String host = array[0];
            int port = Integer.parseInt(array[1]);

            ChannelFuture future = bootstrap.bind(host, port).sync();
            LOGGER.debug(&amp;quot;server started on port {}&amp;quot;, port);

            if (serviceRegistry != null) {
                serviceRegistry.register(serverAddress); // 注册服务地址
            }

            future.channel().closeFuture().sync();
        } finally {
            workerGroup.shutdownGracefully();
            bossGroup.shutdownGracefully();
        }
    }
}

以上代码中，有两个重要的 POJO 需要描述一下，它们分别是RpcRequest与RpcResponse。
使用RpcRequest封装 RPC 请求，代码如下：
&amp;lt;!-- lang: java --&amp;gt;
public class RpcRequest {

    private String requestId;
    private String className;
    private String methodName;
    private Class&amp;lt;?&amp;gt;[] parameterTypes;
    private Object[] parameters;

    // getter/setter...
}

使用RpcResponse封装 RPC 响应，代码如下：
&amp;lt;!-- lang: java --&amp;gt;
public class RpcResponse {

    private String requestId;
    private Throwable error;
    private Object result;

    // getter/setter...
}

使用RpcDecoder提供 RPC 解码，只需扩展 Netty 的ByteToMessageDecoder抽象类的decode方法即可，代码如下：
&amp;lt;!-- lang: java --&amp;gt;
public class RpcDecoder extends ByteToMessageDecoder {

    private Class&amp;lt;?&amp;gt; genericClass;

    public RpcDecoder(Class&amp;lt;?&amp;gt; genericClass) {
        this.genericClass = genericClass;
    }

    @Override
    public void decode(ChannelHandlerContext ctx, ByteBuf in, List&amp;lt;Object&amp;gt; out) throws Exception {
        if (in.readableBytes() &amp;lt; 4) {
            return;
        }
        in.markReaderIndex();
        int dataLength = in.readInt();
        if (dataLength &amp;lt; 0) {
            ctx.close();
        }
        if (in.readableBytes() &amp;lt; dataLength) {
            in.resetReaderIndex();
            return;
        }
        byte[] data = new byte[dataLength];
        in.readBytes(data);

        Object obj = SerializationUtil.deserialize(data, genericClass);
        out.add(obj);
    }
}

使用RpcEncoder提供 RPC 编码，只需扩展 Netty 的MessageToByteEncoder抽象类的encode方法即可，代码如下：
&amp;lt;!-- lang: java --&amp;gt;
public class RpcEncoder extends MessageToByteEncoder {

    private Class&amp;lt;?&amp;gt; genericClass;

    public RpcEncoder(Class&amp;lt;?&amp;gt; genericClass) {
        this.genericClass = genericClass;
    }

    @Override
    public void encode(ChannelHandlerContext ctx, Object in, ByteBuf out) throws Exception {
        if (genericClass.isInstance(in)) {
            byte[] data = SerializationUtil.serialize(in);
            out.writeInt(data.length);
            out.writeBytes(data);
        }
    }
}

编写一个SerializationUtil工具类，使用Protostuff实现序列化：
&amp;lt;!-- lang: java --&amp;gt;
public class SerializationUtil {

    private static Map&amp;lt;Class&amp;lt;?&amp;gt;, Schema&amp;lt;?&amp;gt;&amp;gt; cachedSchema = new ConcurrentHashMap&amp;lt;&amp;gt;();

    private static Objenesis objenesis = new ObjenesisStd(true);

    private SerializationUtil() {
    }

    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
    private static &amp;lt;T&amp;gt; Schema&amp;lt;T&amp;gt; getSchema(Class&amp;lt;T&amp;gt; cls) {
        Schema&amp;lt;T&amp;gt; schema = (Schema&amp;lt;T&amp;gt;) cachedSchema.get(cls);
        if (schema == null) {
            schema = RuntimeSchema.createFrom(cls);
            if (schema != null) {
                cachedSchema.put(cls, schema);
            }
        }
        return schema;
    }

    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
    public static &amp;lt;T&amp;gt; byte[] serialize(T obj) {
        Class&amp;lt;T&amp;gt; cls = (Class&amp;lt;T&amp;gt;) obj.getClass();
        LinkedBuffer buffer = LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE);
        try {
            Schema&amp;lt;T&amp;gt; schema = getSchema(cls);
            return ProtostuffIOUtil.toByteArray(obj, schema, buffer);
        } catch (Exception e) {
            throw new IllegalStateException(e.getMessage(), e);
        } finally {
            buffer.clear();
        }
    }

    public static &amp;lt;T&amp;gt; T deserialize(byte[] data, Class&amp;lt;T&amp;gt; cls) {
        try {
            T message = (T) objenesis.newInstance(cls);
            Schema&amp;lt;T&amp;gt; schema = getSchema(cls);
            ProtostuffIOUtil.mergeFrom(data, message, schema);
            return message;
        } catch (Exception e) {
            throw new IllegalStateException(e.getMessage(), e);
        }
    }
}

以上了使用 Objenesis 来实例化对象，它是比 Java 反射更加强大。
注意：如需要替换其它序列化框架，只需修改SerializationUtil即可。当然，更好的实现方式是提供配置项来决定使用哪种序列化方式。
使用RpcHandler中处理 RPC 请求，只需扩展 Netty 的SimpleChannelInboundHandler抽象类即可，代码如下：
&amp;lt;!-- lang: java --&amp;gt;
public class RpcHandler extends SimpleChannelInboundHandler&amp;lt;RpcRequest&amp;gt; {

    private static final Logger LOGGER = LoggerFactory.getLogger(RpcHandler.class);

    private final Map&amp;lt;String, Object&amp;gt; handlerMap;

    public RpcHandler(Map&amp;lt;String, Object&amp;gt; handlerMap) {
        this.handlerMap = handlerMap;
    }

    @Override
    public void channelRead0(final ChannelHandlerContext ctx, RpcRequest request) throws Exception {
        RpcResponse response = new RpcResponse();
        response.setRequestId(request.getRequestId());
        try {
            Object result = handle(request);
            response.setResult(result);
        } catch (Throwable t) {
            response.setError(t);
        }
        ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);
    }

    private Object handle(RpcRequest request) throws Throwable {
        String className = request.getClassName();
        Object serviceBean = handlerMap.get(className);

        Class&amp;lt;?&amp;gt; serviceClass = serviceBean.getClass();
        String methodName = request.getMethodName();
        Class&amp;lt;?&amp;gt;[] parameterTypes = request.getParameterTypes();
        Object[] parameters = request.getParameters();

        /*Method method = serviceClass.getMethod(methodName, parameterTypes);
        method.setAccessible(true);
        return method.invoke(serviceBean, parameters);*/

        FastClass serviceFastClass = FastClass.create(serviceClass);
        FastMethod serviceFastMethod = serviceFastClass.getMethod(methodName, parameterTypes);
        return serviceFastMethod.invoke(serviceBean, parameters);
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        LOGGER.error(&amp;quot;server caught exception&amp;quot;, cause);
        ctx.close();
    }
}

为了避免使用 Java 反射带来的性能问题，我们可以使用 CGLib 提供的反射 API，如上面用到的FastClass与FastMethod。
同样使用 Spring 配置文件来配置 RPC 客户端，spring.xml代码如下：
&amp;lt;!-- lang: java --&amp;gt;
&amp;lt;beans ...&amp;gt;
    &amp;lt;context:property-placeholder location=&amp;quot;classpath:config.properties&amp;quot;/&amp;gt;

    &amp;lt;!-- 配置服务发现组件 --&amp;gt;
    &amp;lt;bean id=&amp;quot;serviceDiscovery&amp;quot; class=&amp;quot;com.xxx.rpc.registry.ServiceDiscovery&amp;quot;&amp;gt;
        &amp;lt;constructor-arg name=&amp;quot;registryAddress&amp;quot; value=&amp;quot;${registry.address}&amp;quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!-- 配置 RPC 代理 --&amp;gt;
    &amp;lt;bean id=&amp;quot;rpcProxy&amp;quot; class=&amp;quot;com.xxx.rpc.client.RpcProxy&amp;quot;&amp;gt;
        &amp;lt;constructor-arg name=&amp;quot;serviceDiscovery&amp;quot; ref=&amp;quot;serviceDiscovery&amp;quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;

其中config.properties提供了具体的配置：
&amp;lt;!-- lang: java --&amp;gt;
# ZooKeeper 服务器
registry.address=127.0.0.1:2181

同样使用 ZooKeeper 实现服务发现功能，见如下代码：
&amp;lt;!-- lang: java --&amp;gt;
public class ServiceDiscovery {

    private static final Logger LOGGER = LoggerFactory.getLogger(ServiceDiscovery.class);

    private CountDownLatch latch = new CountDownLatch(1);

    private volatile List&amp;lt;String&amp;gt; dataList = new ArrayList&amp;lt;&amp;gt;();

    private String registryAddress;

    public ServiceDiscovery(String registryAddress) {
        this.registryAddress = registryAddress;

        ZooKeeper zk = connectServer();
        if (zk != null) {
            watchNode(zk);
        }
    }

    public String discover() {
        String data = null;
        int size = dataList.size();
        if (size &amp;gt; 0) {
            if (size == 1) {
                data = dataList.get(0);
                LOGGER.debug(&amp;quot;using only data: {}&amp;quot;, data);
            } else {
                data = dataList.get(ThreadLocalRandom.current().nextInt(size));
                LOGGER.debug(&amp;quot;using random data: {}&amp;quot;, data);
            }
        }
        return data;
    }

    private ZooKeeper connectServer() {
        ZooKeeper zk = null;
        try {
            zk = new ZooKeeper(registryAddress, Constant.ZK_SESSION_TIMEOUT, new Watcher() {
                @Override
                public void process(WatchedEvent event) {
                    if (event.getState() == Event.KeeperState.SyncConnected) {
                        latch.countDown();
                    }
                }
            });
            latch.await();
        } catch (IOException | InterruptedException e) {
            LOGGER.error(&amp;quot;&amp;quot;, e);
        }
        return zk;
    }

    private void watchNode(final ZooKeeper zk) {
        try {
            List&amp;lt;String&amp;gt; nodeList = zk.getChildren(Constant.ZK_REGISTRY_PATH, new Watcher() {
                @Override
                public void process(WatchedEvent event) {
                    if (event.getType() == Event.EventType.NodeChildrenChanged) {
                        watchNode(zk);
                    }
                }
            });
            List&amp;lt;String&amp;gt; dataList = new ArrayList&amp;lt;&amp;gt;();
            for (String node : nodeList) {
                byte[] bytes = zk.getData(Constant.ZK_REGISTRY_PATH + &amp;quot;/&amp;quot; + node, false, null);
                dataList.add(new String(bytes));
            }
            LOGGER.debug(&amp;quot;node data: {}&amp;quot;, dataList);
            this.dataList = dataList;
        } catch (KeeperException | InterruptedException e) {
            LOGGER.error(&amp;quot;&amp;quot;, e);
        }
    }
}

这里使用 Java 提供的动态代理技术实现 RPC 代理（当然也可以使用 CGLib 来实现），具体代码如下：
&amp;lt;!-- lang: java --&amp;gt;
public class RpcProxy {

    private String serverAddress;
    private ServiceDiscovery serviceDiscovery;

    public RpcProxy(String serverAddress) {
        this.serverAddress = serverAddress;
    }

    public RpcProxy(ServiceDiscovery serviceDiscovery) {
        this.serviceDiscovery = serviceDiscovery;
    }

    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
    public &amp;lt;T&amp;gt; T create(Class&amp;lt;?&amp;gt; interfaceClass) {
        return (T) Proxy.newProxyInstance(
            interfaceClass.getClassLoader(),
            new Class&amp;lt;?&amp;gt;[]{interfaceClass},
            new InvocationHandler() {
                @Override
                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                    RpcRequest request = new RpcRequest(); // 创建并初始化 RPC 请求
                    request.setRequestId(UUID.randomUUID().toString());
                    request.setClassName(method.getDeclaringClass().getName());
                    request.setMethodName(method.getName());
                    request.setParameterTypes(method.getParameterTypes());
                    request.setParameters(args);

                    if (serviceDiscovery != null) {
                        serverAddress = serviceDiscovery.discover(); // 发现服务
                    }

                    String[] array = serverAddress.split(&amp;quot;:&amp;quot;);
                    String host = array[0];
                    int port = Integer.parseInt(array[1]);

                    RpcClient client = new RpcClient(host, port); // 初始化 RPC 客户端
                    RpcResponse response = client.send(request); // 通过 RPC 客户端发送 RPC 请求并获取 RPC 响应

                    if (response.isError()) {
                        throw response.getError();
                    } else {
                        return response.getResult();
                    }
                }
            }
        );
    }
}

使用RpcClient类实现 RPC 客户端，只需扩展 Netty 提供的SimpleChannelInboundHandler抽象类即可，代码如下：
&amp;lt;!-- lang: java --&amp;gt;
public class RpcClient extends SimpleChannelInboundHandler&amp;lt;RpcResponse&amp;gt; {

    private static final Logger LOGGER = LoggerFactory.getLogger(RpcClient.class);

    private String host;
    private int port;

    private RpcResponse response;

    private final Object obj = new Object();

    public RpcClient(String host, int port) {
        this.host = host;
        this.port = port;
    }

    @Override
    public void channelRead0(ChannelHandlerContext ctx, RpcResponse response) throws Exception {
        this.response = response;

        synchronized (obj) {
            obj.notifyAll(); // 收到响应，唤醒线程
        }
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        LOGGER.error(&amp;quot;client caught exception&amp;quot;, cause);
        ctx.close();
    }

    public RpcResponse send(RpcRequest request) throws Exception {
        EventLoopGroup group = new NioEventLoopGroup();
        try {
            Bootstrap bootstrap = new Bootstrap();
            bootstrap.group(group).channel(NioSocketChannel.class)
                .handler(new ChannelInitializer&amp;lt;SocketChannel&amp;gt;() {
                    @Override
                    public void initChannel(SocketChannel channel) throws Exception {
                        channel.pipeline()
                            .addLast(new RpcEncoder(RpcRequest.class)) // 将 RPC 请求进行编码（为了发送请求）
                            .addLast(new RpcDecoder(RpcResponse.class)) // 将 RPC 响应进行解码（为了处理响应）
                            .addLast(RpcClient.this); // 使用 RpcClient 发送 RPC 请求
                    }
                })
                .option(ChannelOption.SO_KEEPALIVE, true);

            ChannelFuture future = bootstrap.connect(host, port).sync();
            future.channel().writeAndFlush(request).sync();

            synchronized (obj) {
                obj.wait(); // 未收到响应，使线程等待
            }

            if (response != null) {
                future.channel().closeFuture().sync();
            }
            return response;
        } finally {
            group.shutdownGracefully();
        }
    }
}

使用 JUnit 结合 Spring 编写一个单元测试，代码如下：
&amp;lt;!-- lang: java --&amp;gt;
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &amp;quot;classpath:spring.xml&amp;quot;)
public class HelloServiceTest {

    @Autowired
    private RpcProxy rpcProxy;

    @Test
    public void helloTest() {
        HelloService helloService = rpcProxy.create(HelloService.class);
        String result = helloService.hello(&amp;quot;World&amp;quot;);
        Assert.assertEquals(&amp;quot;Hello! World&amp;quot;, result);
    }
}

运行以上单元测试，如果不出意外的话，您应该会看到绿条。
本文通过 Spring + Netty + Protostuff + ZooKeeper 实现了一个轻量级 RPC 框架，使用 Spring 提供依赖注入与参数配置，使用 Netty 实现 NIO 方式的数据传输，使用 Protostuff 实现对象序列化，使用 ZooKeeper 实现服务注册与发现。使用该框架，可将服务部署到分布式环境中的任意节点上，客户端通过远程接口来调用服务端的具体实现，让服务端与客户端的开发完全分离，为实现大规模分布式应用提供了基础支持。
&amp;lt;!-- lang: xml --&amp;gt;
&amp;lt;!-- JUnit --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;4.11&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!-- SLF4J --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;slf4j-log4j12&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.7.7&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!-- Spring --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.2.12.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-test&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.2.12.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!-- Netty --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.netty&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;netty-all&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;4.0.24.Final&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!-- Protostuff --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.dyuproject.protostuff&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;protostuff-core&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0.8&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.dyuproject.protostuff&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;protostuff-runtime&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0.8&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!-- ZooKeeper --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.zookeeper&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;zookeeper&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.4.6&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!-- Apache Commons Collections --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.commons&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;commons-collections4&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;4.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!-- Objenesis --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.objenesis&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;objenesis&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!-- CGLib --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;cglib&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;cglib&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;


源码地址：http://git.oschina.net/huangyong/rpc


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://zhch602.github.io/post/qing-liang-ji-fen-bu-shi-rpc-kuang-jia">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://zhch602.github.io/post/zai-gao-bing-fa-de-he-xin-ji-zhu-zhong-ru-he-shi-xian-mi-deng-xing">
                        在高并发的核心技术中如何实现幂等性
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-05-06</time>
                    
                        <a href="https://zhch602.github.io/tag/imQ_OK1Mz" class="post-tag i-tag
                            i-tag-other_1">
            #java
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            实际系统中有很多操作，是不管做多少次，都应该产生一样的效果或返回一样的结果。
例如：
1. 前端重复提交选中的数据，应该后台只产生对应这个数据的一个反应结果。
2. 我们发起一笔付款请求，应该只扣用户账户一次钱，当遇到网络重发或系统bug重发，也应该只扣一次钱；
3. 发送消息，也应该只发一次，同样的短信发给用户，用户会崩溃；
4. 创建业务订单，一次业务请求只能创建一个，创建多个就会出大问题。
等等很多重要的情况，这些逻辑都需要幂等的特性来支持。
下面说说幂等性概念：
幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。
在编程中，一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“getUsername()和setTrue()”函数就是一个幂等函数。
更复杂的操作幂等保证是利用唯一交易号(流水号)实现.
用通俗的话讲，幂等就是一个操作，不论执行多少次，产生的效果和返回的结果都是一样的。
实现幂等性的技术方案
1. 查询操作
查询一次和查询多次，在数据不变的情况下，查询结果是一样的，select是天然的幂等操作。
2. 删除操作
删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果多个)。
3.唯一索引，防止新增脏数据
比如：支付宝的资金账户，支付宝也有用户账户，每个用户只能有一个资金账户，怎么防止给用户创建资金账户多个，那么给资金账户表中的用户ID加唯一索引，所以一个用户新增成功一个资金账户记录。
要点：唯一索引或唯一组合索引来防止新增数据存在脏数据 （当表存在唯一索引，并发时新增报错时，再查询一次就可以了，数据应该已经存在了，返回结果即可）。
4. token机制，防止页面重复提交
业务要求：页面的数据只能被点击提交一次；
发生原因：由于重复点击或者网络重发，或者nginx重发等情况会导致数据被重复提交。
解决办法：
集群环境：采用token加redis（redis单线程的，处理需要排队）
单JVM环境：采用token加redis或token加jvm内存
处理流程：
1. 数据提交前要向服务的申请token，token放到redis或jvm内存，token有效时间
2. 提交后后台校验token，同时删除token，生成新的token返回
token特点： 要申请，一次有效性，可以限流
注意：redis要用删除操作来判断token，删除成功代表token校验通过，如果用select+delete来校验token，存在并发问题，不建议使用
5. 悲观锁
获取数据的时候加锁获取
select * from table_xxx where id=&#39;xxx&#39; for update;
注意：id字段一定是主键或者唯一索引，不然是锁表，会出事的。
悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用

6. 乐观锁
乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。
乐观锁的实现方式多种多样可以通过version或者其他状态条件：
1. 通过版本号实现
update table_xxx set name=#name#,version=version+1 where version=#version#
2. 通过条件限制
update table_xxx set avai_amount=avai_amount-#subAmount# where avai_amount-#subAmount# &amp;gt;= 0
要求：quality-#subQuality# &amp;gt;= ，这个情景适合不用版本号，只更新是做数据安全校验，适合库存模型，扣份额和回滚份额，性能更高。
注意：乐观锁的更新操作，最好用主键或者唯一索引来更新,这样是行锁，否则更新时会锁表，上面两个sql改成下面的两个更好。
update table_xxx set name=#name#,version=version+1 where id=#id# and version=#version#
update table_xxx set avai_amount=avai_amount-#subAmount# where id=#id# and avai_amount-#subAmount# &amp;gt;= 0
7. 分布式锁
还是拿插入数据的例子，如果是分布是系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定，这时候可以引入分布式锁，通过第三方的系统(redis或zookeeper)，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁，这样其实是把多线程并发的锁的思路，引入多多个系统，也就是分布式系统中得解决思路。
要点：某个长流程处理过程要求不能并发执行，可以在流程执行之前根据某个标志(用户ID+后缀等)获取分布式锁，其他流程执行时获取锁就会失败，也就是同一时间该流程只能有一个能执行成功，执行完成后，释放分布式锁(分布式锁要第三方系统提供)。
8. select + insert
并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了。
注意：核心高并发流程不要用这种方法。
9. 状态机幂等
在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机(状态变更图)，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机，这时候，如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。
注意：订单等单据类业务，存在很长的状态流转，一定要深刻理解状态机，对业务系统设计能力提高有很大帮助。
10. 对外提供接口的api如何保证幂等
如银联提供的付款接口：需要接入商户提交付款请求时附带：source来源，seq序列号
source+seq在数据库里面做唯一索引，防止多次付款，(并发时，只能处理一个请求)。
重点：
对外提供接口为了支持幂等调用，接口有两个字段必须传，一个是来源source，一个是来源方序列号seq，这个两个字段在提供方系统里面做联合唯一索引，这样当第三方调用时，先在本方系统里面查询一下，是否已经处理过，返回相应处理结果；没有处理过，进行相应处理，返回结果。注意，为了幂等友好，一定要先查询一下，是否处理过该笔业务，不查询直接插入业务系统，会报错，但实际已经处理了。
最后总结：
幂等性应该是合格程序员的一个基因，在设计系统时，是首要考虑的问题，尤其是在像第三方支付平台，银行，互联网金融公司等涉及的网上资金系统，既要高效，数据也要准确，所以不能出现多扣款，多打款等问题，这样会很难处理，并会大大降低用户体验。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://zhch602.github.io/post/zai-gao-bing-fa-de-he-xin-ji-zhu-zhong-ru-he-shi-xian-mi-deng-xing">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://zhch602.github.io/post/uuid">
                        UUID
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2018-05-06</time>
                    
                        <a href="https://zhch602.github.io/tag/imQ_OK1Mz" class="post-tag i-tag
                            i-tag-other_3">
            #java
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            首先，即便是虚拟机的话MAC地址也是不一样的。另外你说的统一时间还是个宏观的概念，这个仅仅是决定了UUID生产串中的某一部分相同而已，因为为了保证UUID的唯一性，规范定义了包括网卡MAC地址、时间戳、名字空间（Namespace）、随机或伪随机数、时序等元素。
当然，你要说UUID是不是绝对的不会出现重复的，这个也不能这样说的（我下面会提到）。
UUID具有以下涵义：
经由一定的算法机器生成
为了保证UUID的唯一性，规范定义了包括网卡MAC地址、时间戳、名字空间（Namespace）、随机或伪随机数、时序等元素，以及从这些元素生成UUID的算法。UUID的复杂特性在保证了其唯一性的同时，意味着只能由计算机生成。
非人工指定，非人工识别
UUID是不能人工指定的，除非你冒着UUID重复的风险。UUID的复杂性决定了“一般人“不能直接从一个UUID知道哪个对象和它关联。
在特定的范围内重复的可能性极小
UUID的生成规范定义的算法主要目的就是要保证其唯一性。但这个唯一性是有限的，只在特定的范围内才能得到保证，这和UUID的类型有关（参见UUID的版本）。
UUID的版本UUID具有多个版本，每个版本的算法不同，应用范围也不同。
首先是一个特例－－Nil UUID－－通常我们不会用到它，它是由全为0的数字组成，如下：
00000000-0000-0000-0000-000000000000
UUID Version 1：基于时间的UUID
基于时间的UUID通过计算当前时间戳、随机数和机器MAC地址得到。由于在算法中使用了MAC地址，这个版本的UUID可以保证在全球范围的唯一性。但与此同时，使用MAC地址会带来安全性问题，这就是这个版本UUID受到批评的地方。如果应用只是在局域网中使用，也可以使用退化的算法，以IP地址来代替MAC地址－－Java的UUID往往是这样实现的（当然也考虑了获取MAC的难度）。
UUID Version 2：DCE安全的UUID
DCE（Distributed Computing Environment）安全的UUID和基于时间的UUID算法相同，但会把时间戳的前4位置换为POSIX的UID或GID。这个版本的UUID在实际中较少用到。
UUID Version 3：基于名字的UUID（MD5）
基于名字的UUID通过计算名字和名字空间的MD5散列值得到。这个版本的UUID保证了：相同名字空间中不同名字生成的UUID的唯一性；不同名字空间中的UUID的唯一性；相同名字空间中相同名字的UUID重复生成是相同的。
UUID Version 4：随机UUID
根据随机数，或者伪随机数生成UUID。这种UUID产生重复的概率是可以计算出来的，但随机的东西就像是买彩票：你指望它发财是不可能的，但狗屎运通常会在不经意中到来。
UUID Version 5：基于名字的UUID（SHA1）
和版本3的UUID算法类似，只是散列值计算使用SHA1（Secure Hash Algorithm 1）算法。
UUID的应用从UUID的不同版本可以看出，
Version 1/2适合应用于分布式计算环境下，具有高度的唯一性；
Version 3/5适合于一定范围内名字唯一，且需要或可能会重复生成UUID的环境下；
至于Version 4，个人的建议是最好不用（虽然它是最简单最方便的）。
通常我们建议使用UUID来标识对象或持久化数据，但以下情况最好不使用UUID：
映射类型的对象。比如只有代码及名称的代码表。
人工维护的非系统生成对象。比如系统中的部分基础数据。
对于具有名称不可重复的自然特性的对象，最好使用Version 3/5的UUID。比如系统中的用户。如果用户的UUID是Version 1的，如果你不小心删除了再重建用户，你会发现人还是那个人，用户已经不是那个用户了。（虽然标记为删除状态也是一种解决方案，但会带来实现上的复杂性。）

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://zhch602.github.io/post/uuid">Read More ~</a>
                            </div>
                </div>
            </article>
            
                <!-- 翻页 -->
                
                </div>
                <!--  -->
                <div class="main-container-middle"></div>
                <!--  -->
                <div id="sidebar" class="main-container-right">

                    <!-- 个人信息 -->
                    
    <div class="id_card i-card">
        <div class="id_card-avatar" style="background-image: url(https://zhch602.github.io/images/avatar.png?v=1573799572364)">
        </div>
        <h1 class="id_card-title">
            InJune&#39;s Blog
        </h1>
        <h2 class="id_card-description">
            天道酬勤
        </h2>
        <!--  -->
        <div class="id_card-sns">
            <!-- github -->
            
                <a href="https://github.com/zhch602" target="_blank" rel="noopener noreferrer"><i
                class="fa fa-github"></i></a>
                
                    <!-- twitter -->
                    
                        <a href="https://twitter.com/zhch602" target="_blank" rel="noopener noreferrer"><i
                class="fa fa-twitter"></i></a>
                        
                            <!-- weibo -->
                            
                                <a href="https://weibo.com/5207780273" target="_blank" rel="noopener noreferrer"><i
                class="fa fa-weibo"></i></a>
                                
                                    <!-- facebook -->
                                    
                                        <a href="https://www.facebook.com/zhch602" target="_blank" rel="noopener noreferrer"><i
                class="fa fa-facebook"></i></a>
                                        

        </div>
    </div>
    

                        <!-- 公告栏 -->
                        

                </div>
            </div>



            <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://zhch602.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
</body>

</html>