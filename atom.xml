<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zhch602.github.io</id>
    <title>InJune&apos;s Blog</title>
    <updated>2019-11-14T08:57:37.785Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zhch602.github.io"/>
    <link rel="self" href="https://zhch602.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://zhch602.github.io/images/avatar.png</logo>
    <icon>https://zhch602.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, InJune&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[轻量级分布式 RPC 框架]]></title>
        <id>https://zhch602.github.io/post/qing-liang-ji-fen-bu-shi-rpc-kuang-jia</id>
        <link href="https://zhch602.github.io/post/qing-liang-ji-fen-bu-shi-rpc-kuang-jia">
        </link>
        <updated>2019-05-06T08:14:20.000Z</updated>
        <content type="html"><![CDATA[<p>RPC，即 Remote Procedure Call（远程过程调用），说得通俗一点就是：调用远程计算机上的服务，就像调用本地服务一样。</p>
<p>RPC 可基于 HTTP 或 TCP 协议，Web Service 就是基于 HTTP 协议的 RPC，它具有良好的跨平台性，但其性能却不如基于 TCP 协议的 RPC。会两方面会直接影响 RPC 的性能，一是传输方式，二是序列化。</p>
<p>众所周知，TCP 是传输层协议，HTTP 是应用层协议，而传输层较应用层更加底层，在数据传输方面，越底层越快，因此，在一般情况下，TCP 一定比 HTTP 快。就序列化而言，Java 提供了默认的序列化方式，但在高并发的情况下，这种方式将会带来一些性能上的瓶颈，于是市面上出现了一系列优秀的序列化框架，比如：Protobuf、Kryo、Hessian、Jackson 等，它们可以取代 Java 默认的序列化，从而提供更高效的性能。</p>
<p>为了支持高并发，传统的阻塞式 IO 显然不太合适，因此我们需要异步的 IO，即 NIO。Java 提供了 NIO 的解决方案，Java 7 也提供了更优秀的 NIO.2 支持，用 Java 实现 NIO 并不是遥不可及的事情，只是需要我们熟悉 NIO 的技术细节。</p>
<p>我们需要将服务部署在分布式环境下的不同节点上，通过服务注册的方式，让客户端来自动发现当前可用的服务，并调用这些服务。这需要一种服务注册表（Service Registry）的组件，让它来注册分布式环境下所有的服务地址（包括：主机名与端口号）。</p>
<p>应用、服务、服务注册表之间的关系见下图：</p>
<figure data-type="image" tabindex="1"><img src="http://static.oschina.net/uploads/space/2014/1229/002234_ENsM_223750.png" alt="系统架构"></figure>
<p>每台 Server 上可发布多个 Service，这些 Service 共用一个 host 与 port，在分布式环境下会提供 Server 共同对外提供 Service。此外，为防止 Service Registry 出现单点故障，因此需要将其搭建为集群环境。</p>
<p>本文将为您揭晓开发轻量级分布式 RPC 框架的具体过程，该框架基于 TCP 协议，提供了 NIO 特性，提供高效的序列化方式，同时也具备服务注册与发现的能力。</p>
<p>根据以上技术需求，我们可使用如下技术选型：</p>
<ol>
<li>Spring：它是最强大的依赖注入框架，也是业界的权威标准。</li>
<li>Netty：它使 NIO 编程更加容易，屏蔽了 Java 底层的 NIO 细节。</li>
<li>Protostuff：它基于 Protobuf 序列化框架，面向 POJO，无需编写 .proto 文件。</li>
<li>ZooKeeper：提供服务注册与发现功能，开发分布式系统的必备选择，同时它也具备天生的集群能力。</li>
</ol>
<p>相关 Maven 依赖请见附录。</p>
<pre><code>&lt;!-- lang: java --&gt;
public interface HelloService {

    String hello(String name);
}
</code></pre>
<p>将该接口放在独立的客户端 jar 包中，以供应用使用。</p>
<pre><code>&lt;!-- lang: java --&gt;
@RpcService(HelloService.class) // 指定远程接口
public class HelloServiceImpl implements HelloService {

    @Override
    public String hello(String name) {
        return &quot;Hello! &quot; + name;
    }
}
</code></pre>
<p>使用<code>RpcService</code>注解定义在服务接口的实现类上，需要对该实现类指定远程接口，因为实现类可能会实现多个接口，一定要告诉框架哪个才是远程接口。</p>
<p><code>RpcService</code>代码如下：</p>
<pre><code>&lt;!-- lang: java --&gt;
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Component // 表明可被 Spring 扫描
public @interface RpcService {

    Class&lt;?&gt; value();
}
</code></pre>
<p>该注解具备 Spring 的<code>Component</code>注解的特性，可被 Spring 扫描。</p>
<p>该实现类放在服务端 jar 包中，该 jar 包还提供了一些服务端的配置文件与启动服务的引导程序。</p>
<p>服务端 Spring 配置文件名为<code>spring.xml</code>，内容如下：</p>
<pre><code>&lt;!-- lang: xml --&gt;
&lt;beans ...&gt;
    &lt;context:component-scan base-package=&quot;com.xxx.rpc.sample.server&quot;/&gt;

    &lt;context:property-placeholder location=&quot;classpath:config.properties&quot;/&gt;

    &lt;!-- 配置服务注册组件 --&gt;
    &lt;bean id=&quot;serviceRegistry&quot; class=&quot;com.xxx.rpc.registry.ServiceRegistry&quot;&gt;
        &lt;constructor-arg name=&quot;registryAddress&quot; value=&quot;${registry.address}&quot;/&gt;
    &lt;/bean&gt;

    &lt;!-- 配置 RPC 服务器 --&gt;
    &lt;bean id=&quot;rpcServer&quot; class=&quot;com.xxx.rpc.server.RpcServer&quot;&gt;
        &lt;constructor-arg name=&quot;serverAddress&quot; value=&quot;${server.address}&quot;/&gt;
        &lt;constructor-arg name=&quot;serviceRegistry&quot; ref=&quot;serviceRegistry&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>具体的配置参数在<code>config.properties</code>文件中，内容如下：</p>
<pre><code>&lt;!-- lang: java --&gt;
# ZooKeeper 服务器
registry.address=127.0.0.1:2181

# RPC 服务器
server.address=127.0.0.1:8000
</code></pre>
<p>以上配置表明：连接本地的 ZooKeeper 服务器，并在 8000 端口上发布 RPC 服务。</p>
<p>为了加载 Spring 配置文件来发布服务，只需编写一个引导程序即可：</p>
<pre><code>&lt;!-- lang: java --&gt;
public class RpcBootstrap {

    public static void main(String[] args) {
        new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
    }
}
</code></pre>
<p>运行<code>RpcBootstrap</code>类的<code>main</code>方法即可启动服务端，但还有两个重要的组件尚未实现，它们分别是：<code>ServiceRegistry</code>与<code>RpcServer</code>，下文会给出具体实现细节。</p>
<p>使用 ZooKeeper 客户端可轻松实现服务注册功能，<code>ServiceRegistry</code>代码如下：</p>
<pre><code>&lt;!-- lang: java --&gt;
public class ServiceRegistry {

    private static final Logger LOGGER = LoggerFactory.getLogger(ServiceRegistry.class);

    private CountDownLatch latch = new CountDownLatch(1);

    private String registryAddress;

    public ServiceRegistry(String registryAddress) {
        this.registryAddress = registryAddress;
    }

    public void register(String data) {
        if (data != null) {
            ZooKeeper zk = connectServer();
            if (zk != null) {
                createNode(zk, data);
            }
        }
    }

    private ZooKeeper connectServer() {
        ZooKeeper zk = null;
        try {
            zk = new ZooKeeper(registryAddress, Constant.ZK_SESSION_TIMEOUT, new Watcher() {
                @Override
                public void process(WatchedEvent event) {
                    if (event.getState() == Event.KeeperState.SyncConnected) {
                        latch.countDown();
                    }
                }
            });
            latch.await();
        } catch (IOException | InterruptedException e) {
            LOGGER.error(&quot;&quot;, e);
        }
        return zk;
    }

    private void createNode(ZooKeeper zk, String data) {
        try {
            byte[] bytes = data.getBytes();
            String path = zk.create(Constant.ZK_DATA_PATH, bytes, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);
            LOGGER.debug(&quot;create zookeeper node ({} =&gt; {})&quot;, path, data);
        } catch (KeeperException | InterruptedException e) {
            LOGGER.error(&quot;&quot;, e);
        }
    }
}
</code></pre>
<p>其中，通过<code>Constant</code>配置了所有的常量：</p>
<pre><code>&lt;!-- lang: java --&gt;
public interface Constant {

    int ZK_SESSION_TIMEOUT = 5000;

    String ZK_REGISTRY_PATH = &quot;/registry&quot;;
    String ZK_DATA_PATH = ZK_REGISTRY_PATH + &quot;/data&quot;;
}
</code></pre>
<p>注意：首先需要使用 ZooKeeper 客户端命令行创建<code>/registry</code>永久节点，用于存放所有的服务临时节点。</p>
<p>使用 Netty 可实现一个支持 NIO 的 RPC 服务器，需要使用<code>ServiceRegistry</code>注册服务地址，<code>RpcServer</code>代码如下：</p>
<pre><code>&lt;!-- lang: java --&gt;
public class RpcServer implements ApplicationContextAware, InitializingBean {

    private static final Logger LOGGER = LoggerFactory.getLogger(RpcServer.class);

    private String serverAddress;
    private ServiceRegistry serviceRegistry;

    private Map&lt;String, Object&gt; handlerMap = new HashMap&lt;&gt;(); // 存放接口名与服务对象之间的映射关系

    public RpcServer(String serverAddress) {
        this.serverAddress = serverAddress;
    }

    public RpcServer(String serverAddress, ServiceRegistry serviceRegistry) {
        this.serverAddress = serverAddress;
        this.serviceRegistry = serviceRegistry;
    }

    @Override
    public void setApplicationContext(ApplicationContext ctx) throws BeansException {
        Map&lt;String, Object&gt; serviceBeanMap = ctx.getBeansWithAnnotation(RpcService.class); // 获取所有带有 RpcService 注解的 Spring Bean
        if (MapUtils.isNotEmpty(serviceBeanMap)) {
            for (Object serviceBean : serviceBeanMap.values()) {
                String interfaceName = serviceBean.getClass().getAnnotation(RpcService.class).value().getName();
                handlerMap.put(interfaceName, serviceBean);
            }
        }
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap bootstrap = new ServerBootstrap();
            bootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)
                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {
                    @Override
                    public void initChannel(SocketChannel channel) throws Exception {
                        channel.pipeline()
                            .addLast(new RpcDecoder(RpcRequest.class)) // 将 RPC 请求进行解码（为了处理请求）
                            .addLast(new RpcEncoder(RpcResponse.class)) // 将 RPC 响应进行编码（为了返回响应）
                            .addLast(new RpcHandler(handlerMap)); // 处理 RPC 请求
                    }
                })
                .option(ChannelOption.SO_BACKLOG, 128)
                .childOption(ChannelOption.SO_KEEPALIVE, true);

            String[] array = serverAddress.split(&quot;:&quot;);
            String host = array[0];
            int port = Integer.parseInt(array[1]);

            ChannelFuture future = bootstrap.bind(host, port).sync();
            LOGGER.debug(&quot;server started on port {}&quot;, port);

            if (serviceRegistry != null) {
                serviceRegistry.register(serverAddress); // 注册服务地址
            }

            future.channel().closeFuture().sync();
        } finally {
            workerGroup.shutdownGracefully();
            bossGroup.shutdownGracefully();
        }
    }
}
</code></pre>
<p>以上代码中，有两个重要的 POJO 需要描述一下，它们分别是<code>RpcRequest</code>与<code>RpcResponse</code>。</p>
<p>使用<code>RpcRequest</code>封装 RPC 请求，代码如下：</p>
<pre><code>&lt;!-- lang: java --&gt;
public class RpcRequest {

    private String requestId;
    private String className;
    private String methodName;
    private Class&lt;?&gt;[] parameterTypes;
    private Object[] parameters;

    // getter/setter...
}
</code></pre>
<p>使用<code>RpcResponse</code>封装 RPC 响应，代码如下：</p>
<pre><code>&lt;!-- lang: java --&gt;
public class RpcResponse {

    private String requestId;
    private Throwable error;
    private Object result;

    // getter/setter...
}
</code></pre>
<p>使用<code>RpcDecoder</code>提供 RPC 解码，只需扩展 Netty 的<code>ByteToMessageDecoder</code>抽象类的<code>decode</code>方法即可，代码如下：</p>
<pre><code>&lt;!-- lang: java --&gt;
public class RpcDecoder extends ByteToMessageDecoder {

    private Class&lt;?&gt; genericClass;

    public RpcDecoder(Class&lt;?&gt; genericClass) {
        this.genericClass = genericClass;
    }

    @Override
    public void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception {
        if (in.readableBytes() &lt; 4) {
            return;
        }
        in.markReaderIndex();
        int dataLength = in.readInt();
        if (dataLength &lt; 0) {
            ctx.close();
        }
        if (in.readableBytes() &lt; dataLength) {
            in.resetReaderIndex();
            return;
        }
        byte[] data = new byte[dataLength];
        in.readBytes(data);

        Object obj = SerializationUtil.deserialize(data, genericClass);
        out.add(obj);
    }
}
</code></pre>
<p>使用<code>RpcEncoder</code>提供 RPC 编码，只需扩展 Netty 的<code>MessageToByteEncoder</code>抽象类的<code>encode</code>方法即可，代码如下：</p>
<pre><code>&lt;!-- lang: java --&gt;
public class RpcEncoder extends MessageToByteEncoder {

    private Class&lt;?&gt; genericClass;

    public RpcEncoder(Class&lt;?&gt; genericClass) {
        this.genericClass = genericClass;
    }

    @Override
    public void encode(ChannelHandlerContext ctx, Object in, ByteBuf out) throws Exception {
        if (genericClass.isInstance(in)) {
            byte[] data = SerializationUtil.serialize(in);
            out.writeInt(data.length);
            out.writeBytes(data);
        }
    }
}
</code></pre>
<p>编写一个<code>SerializationUtil</code>工具类，使用<code>Protostuff</code>实现序列化：</p>
<pre><code>&lt;!-- lang: java --&gt;
public class SerializationUtil {

    private static Map&lt;Class&lt;?&gt;, Schema&lt;?&gt;&gt; cachedSchema = new ConcurrentHashMap&lt;&gt;();

    private static Objenesis objenesis = new ObjenesisStd(true);

    private SerializationUtil() {
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private static &lt;T&gt; Schema&lt;T&gt; getSchema(Class&lt;T&gt; cls) {
        Schema&lt;T&gt; schema = (Schema&lt;T&gt;) cachedSchema.get(cls);
        if (schema == null) {
            schema = RuntimeSchema.createFrom(cls);
            if (schema != null) {
                cachedSchema.put(cls, schema);
            }
        }
        return schema;
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; byte[] serialize(T obj) {
        Class&lt;T&gt; cls = (Class&lt;T&gt;) obj.getClass();
        LinkedBuffer buffer = LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE);
        try {
            Schema&lt;T&gt; schema = getSchema(cls);
            return ProtostuffIOUtil.toByteArray(obj, schema, buffer);
        } catch (Exception e) {
            throw new IllegalStateException(e.getMessage(), e);
        } finally {
            buffer.clear();
        }
    }

    public static &lt;T&gt; T deserialize(byte[] data, Class&lt;T&gt; cls) {
        try {
            T message = (T) objenesis.newInstance(cls);
            Schema&lt;T&gt; schema = getSchema(cls);
            ProtostuffIOUtil.mergeFrom(data, message, schema);
            return message;
        } catch (Exception e) {
            throw new IllegalStateException(e.getMessage(), e);
        }
    }
}
</code></pre>
<p>以上了使用 Objenesis 来实例化对象，它是比 Java 反射更加强大。</p>
<p>注意：如需要替换其它序列化框架，只需修改<code>SerializationUtil</code>即可。当然，更好的实现方式是提供配置项来决定使用哪种序列化方式。</p>
<p>使用<code>RpcHandler</code>中处理 RPC 请求，只需扩展 Netty 的<code>SimpleChannelInboundHandler</code>抽象类即可，代码如下：</p>
<pre><code>&lt;!-- lang: java --&gt;
public class RpcHandler extends SimpleChannelInboundHandler&lt;RpcRequest&gt; {

    private static final Logger LOGGER = LoggerFactory.getLogger(RpcHandler.class);

    private final Map&lt;String, Object&gt; handlerMap;

    public RpcHandler(Map&lt;String, Object&gt; handlerMap) {
        this.handlerMap = handlerMap;
    }

    @Override
    public void channelRead0(final ChannelHandlerContext ctx, RpcRequest request) throws Exception {
        RpcResponse response = new RpcResponse();
        response.setRequestId(request.getRequestId());
        try {
            Object result = handle(request);
            response.setResult(result);
        } catch (Throwable t) {
            response.setError(t);
        }
        ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);
    }

    private Object handle(RpcRequest request) throws Throwable {
        String className = request.getClassName();
        Object serviceBean = handlerMap.get(className);

        Class&lt;?&gt; serviceClass = serviceBean.getClass();
        String methodName = request.getMethodName();
        Class&lt;?&gt;[] parameterTypes = request.getParameterTypes();
        Object[] parameters = request.getParameters();

        /*Method method = serviceClass.getMethod(methodName, parameterTypes);
        method.setAccessible(true);
        return method.invoke(serviceBean, parameters);*/

        FastClass serviceFastClass = FastClass.create(serviceClass);
        FastMethod serviceFastMethod = serviceFastClass.getMethod(methodName, parameterTypes);
        return serviceFastMethod.invoke(serviceBean, parameters);
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        LOGGER.error(&quot;server caught exception&quot;, cause);
        ctx.close();
    }
}
</code></pre>
<p>为了避免使用 Java 反射带来的性能问题，我们可以使用 CGLib 提供的反射 API，如上面用到的<code>FastClass</code>与<code>FastMethod</code>。</p>
<p>同样使用 Spring 配置文件来配置 RPC 客户端，<code>spring.xml</code>代码如下：</p>
<pre><code>&lt;!-- lang: java --&gt;
&lt;beans ...&gt;
    &lt;context:property-placeholder location=&quot;classpath:config.properties&quot;/&gt;

    &lt;!-- 配置服务发现组件 --&gt;
    &lt;bean id=&quot;serviceDiscovery&quot; class=&quot;com.xxx.rpc.registry.ServiceDiscovery&quot;&gt;
        &lt;constructor-arg name=&quot;registryAddress&quot; value=&quot;${registry.address}&quot;/&gt;
    &lt;/bean&gt;

    &lt;!-- 配置 RPC 代理 --&gt;
    &lt;bean id=&quot;rpcProxy&quot; class=&quot;com.xxx.rpc.client.RpcProxy&quot;&gt;
        &lt;constructor-arg name=&quot;serviceDiscovery&quot; ref=&quot;serviceDiscovery&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>其中<code>config.properties</code>提供了具体的配置：</p>
<pre><code>&lt;!-- lang: java --&gt;
# ZooKeeper 服务器
registry.address=127.0.0.1:2181
</code></pre>
<p>同样使用 ZooKeeper 实现服务发现功能，见如下代码：</p>
<pre><code>&lt;!-- lang: java --&gt;
public class ServiceDiscovery {

    private static final Logger LOGGER = LoggerFactory.getLogger(ServiceDiscovery.class);

    private CountDownLatch latch = new CountDownLatch(1);

    private volatile List&lt;String&gt; dataList = new ArrayList&lt;&gt;();

    private String registryAddress;

    public ServiceDiscovery(String registryAddress) {
        this.registryAddress = registryAddress;

        ZooKeeper zk = connectServer();
        if (zk != null) {
            watchNode(zk);
        }
    }

    public String discover() {
        String data = null;
        int size = dataList.size();
        if (size &gt; 0) {
            if (size == 1) {
                data = dataList.get(0);
                LOGGER.debug(&quot;using only data: {}&quot;, data);
            } else {
                data = dataList.get(ThreadLocalRandom.current().nextInt(size));
                LOGGER.debug(&quot;using random data: {}&quot;, data);
            }
        }
        return data;
    }

    private ZooKeeper connectServer() {
        ZooKeeper zk = null;
        try {
            zk = new ZooKeeper(registryAddress, Constant.ZK_SESSION_TIMEOUT, new Watcher() {
                @Override
                public void process(WatchedEvent event) {
                    if (event.getState() == Event.KeeperState.SyncConnected) {
                        latch.countDown();
                    }
                }
            });
            latch.await();
        } catch (IOException | InterruptedException e) {
            LOGGER.error(&quot;&quot;, e);
        }
        return zk;
    }

    private void watchNode(final ZooKeeper zk) {
        try {
            List&lt;String&gt; nodeList = zk.getChildren(Constant.ZK_REGISTRY_PATH, new Watcher() {
                @Override
                public void process(WatchedEvent event) {
                    if (event.getType() == Event.EventType.NodeChildrenChanged) {
                        watchNode(zk);
                    }
                }
            });
            List&lt;String&gt; dataList = new ArrayList&lt;&gt;();
            for (String node : nodeList) {
                byte[] bytes = zk.getData(Constant.ZK_REGISTRY_PATH + &quot;/&quot; + node, false, null);
                dataList.add(new String(bytes));
            }
            LOGGER.debug(&quot;node data: {}&quot;, dataList);
            this.dataList = dataList;
        } catch (KeeperException | InterruptedException e) {
            LOGGER.error(&quot;&quot;, e);
        }
    }
}
</code></pre>
<p>这里使用 Java 提供的动态代理技术实现 RPC 代理（当然也可以使用 CGLib 来实现），具体代码如下：</p>
<pre><code>&lt;!-- lang: java --&gt;
public class RpcProxy {

    private String serverAddress;
    private ServiceDiscovery serviceDiscovery;

    public RpcProxy(String serverAddress) {
        this.serverAddress = serverAddress;
    }

    public RpcProxy(ServiceDiscovery serviceDiscovery) {
        this.serviceDiscovery = serviceDiscovery;
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T&gt; T create(Class&lt;?&gt; interfaceClass) {
        return (T) Proxy.newProxyInstance(
            interfaceClass.getClassLoader(),
            new Class&lt;?&gt;[]{interfaceClass},
            new InvocationHandler() {
                @Override
                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                    RpcRequest request = new RpcRequest(); // 创建并初始化 RPC 请求
                    request.setRequestId(UUID.randomUUID().toString());
                    request.setClassName(method.getDeclaringClass().getName());
                    request.setMethodName(method.getName());
                    request.setParameterTypes(method.getParameterTypes());
                    request.setParameters(args);

                    if (serviceDiscovery != null) {
                        serverAddress = serviceDiscovery.discover(); // 发现服务
                    }

                    String[] array = serverAddress.split(&quot;:&quot;);
                    String host = array[0];
                    int port = Integer.parseInt(array[1]);

                    RpcClient client = new RpcClient(host, port); // 初始化 RPC 客户端
                    RpcResponse response = client.send(request); // 通过 RPC 客户端发送 RPC 请求并获取 RPC 响应

                    if (response.isError()) {
                        throw response.getError();
                    } else {
                        return response.getResult();
                    }
                }
            }
        );
    }
}
</code></pre>
<p>使用<code>RpcClient</code>类实现 RPC 客户端，只需扩展 Netty 提供的<code>SimpleChannelInboundHandler</code>抽象类即可，代码如下：</p>
<pre><code>&lt;!-- lang: java --&gt;
public class RpcClient extends SimpleChannelInboundHandler&lt;RpcResponse&gt; {

    private static final Logger LOGGER = LoggerFactory.getLogger(RpcClient.class);

    private String host;
    private int port;

    private RpcResponse response;

    private final Object obj = new Object();

    public RpcClient(String host, int port) {
        this.host = host;
        this.port = port;
    }

    @Override
    public void channelRead0(ChannelHandlerContext ctx, RpcResponse response) throws Exception {
        this.response = response;

        synchronized (obj) {
            obj.notifyAll(); // 收到响应，唤醒线程
        }
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        LOGGER.error(&quot;client caught exception&quot;, cause);
        ctx.close();
    }

    public RpcResponse send(RpcRequest request) throws Exception {
        EventLoopGroup group = new NioEventLoopGroup();
        try {
            Bootstrap bootstrap = new Bootstrap();
            bootstrap.group(group).channel(NioSocketChannel.class)
                .handler(new ChannelInitializer&lt;SocketChannel&gt;() {
                    @Override
                    public void initChannel(SocketChannel channel) throws Exception {
                        channel.pipeline()
                            .addLast(new RpcEncoder(RpcRequest.class)) // 将 RPC 请求进行编码（为了发送请求）
                            .addLast(new RpcDecoder(RpcResponse.class)) // 将 RPC 响应进行解码（为了处理响应）
                            .addLast(RpcClient.this); // 使用 RpcClient 发送 RPC 请求
                    }
                })
                .option(ChannelOption.SO_KEEPALIVE, true);

            ChannelFuture future = bootstrap.connect(host, port).sync();
            future.channel().writeAndFlush(request).sync();

            synchronized (obj) {
                obj.wait(); // 未收到响应，使线程等待
            }

            if (response != null) {
                future.channel().closeFuture().sync();
            }
            return response;
        } finally {
            group.shutdownGracefully();
        }
    }
}
</code></pre>
<p>使用 JUnit 结合 Spring 编写一个单元测试，代码如下：</p>
<pre><code>&lt;!-- lang: java --&gt;
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &quot;classpath:spring.xml&quot;)
public class HelloServiceTest {

    @Autowired
    private RpcProxy rpcProxy;

    @Test
    public void helloTest() {
        HelloService helloService = rpcProxy.create(HelloService.class);
        String result = helloService.hello(&quot;World&quot;);
        Assert.assertEquals(&quot;Hello! World&quot;, result);
    }
}
</code></pre>
<p>运行以上单元测试，如果不出意外的话，您应该会看到绿条。</p>
<p>本文通过 Spring + Netty + Protostuff + ZooKeeper 实现了一个轻量级 RPC 框架，使用 Spring 提供依赖注入与参数配置，使用 Netty 实现 NIO 方式的数据传输，使用 Protostuff 实现对象序列化，使用 ZooKeeper 实现服务注册与发现。使用该框架，可将服务部署到分布式环境中的任意节点上，客户端通过远程接口来调用服务端的具体实现，让服务端与客户端的开发完全分离，为实现大规模分布式应用提供了基础支持。</p>
<pre><code>&lt;!-- lang: xml --&gt;
&lt;!-- JUnit --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;junit&lt;/groupId&gt;
    &lt;artifactId&gt;junit&lt;/artifactId&gt;
    &lt;version&gt;4.11&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;

&lt;!-- SLF4J --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
    &lt;version&gt;1.7.7&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- Spring --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
    &lt;version&gt;3.2.12.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
    &lt;version&gt;3.2.12.RELEASE&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;

&lt;!-- Netty --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.netty&lt;/groupId&gt;
    &lt;artifactId&gt;netty-all&lt;/artifactId&gt;
    &lt;version&gt;4.0.24.Final&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- Protostuff --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.dyuproject.protostuff&lt;/groupId&gt;
    &lt;artifactId&gt;protostuff-core&lt;/artifactId&gt;
    &lt;version&gt;1.0.8&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.dyuproject.protostuff&lt;/groupId&gt;
    &lt;artifactId&gt;protostuff-runtime&lt;/artifactId&gt;
    &lt;version&gt;1.0.8&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- ZooKeeper --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;
    &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;
    &lt;version&gt;3.4.6&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- Apache Commons Collections --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
    &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;
    &lt;version&gt;4.0&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- Objenesis --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.objenesis&lt;/groupId&gt;
    &lt;artifactId&gt;objenesis&lt;/artifactId&gt;
    &lt;version&gt;2.1&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- CGLib --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;cglib&lt;/groupId&gt;
    &lt;artifactId&gt;cglib&lt;/artifactId&gt;
    &lt;version&gt;3.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<blockquote>
<p>源码地址：<a href="http://git.oschina.net/huangyong/rpc">http://git.oschina.net/huangyong/rpc</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在高并发的核心技术中如何实现幂等性]]></title>
        <id>https://zhch602.github.io/post/zai-gao-bing-fa-de-he-xin-ji-zhu-zhong-ru-he-shi-xian-mi-deng-xing</id>
        <link href="https://zhch602.github.io/post/zai-gao-bing-fa-de-he-xin-ji-zhu-zhong-ru-he-shi-xian-mi-deng-xing">
        </link>
        <updated>2019-05-06T08:13:43.000Z</updated>
        <content type="html"><![CDATA[<p>实际系统中有很多操作，是不管做多少次，都应该产生一样的效果或返回一样的结果。</p>
<p>例如：</p>
<p>1. 前端重复提交选中的数据，应该后台只产生对应这个数据的一个反应结果。</p>
<p>2. 我们发起一笔付款请求，应该只扣用户账户一次钱，当遇到网络重发或系统bug重发，也应该只扣一次钱；</p>
<p>3. 发送消息，也应该只发一次，同样的短信发给用户，用户会崩溃；</p>
<p>4. 创建业务订单，一次业务请求只能创建一个，创建多个就会出大问题。</p>
<p>等等很多重要的情况，这些逻辑都需要幂等的特性来支持。</p>
<p>下面说说幂等性概念：</p>
<p>幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。</p>
<p>在编程中，一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“getUsername()和setTrue()”函数就是一个幂等函数。</p>
<p>更复杂的操作幂等保证是利用唯一交易号(流水号)实现.</p>
<p>用通俗的话讲，幂等就是一个操作，不论执行多少次，产生的效果和返回的结果都是一样的。</p>
<p>实现幂等性的技术方案</p>
<p>1. 查询操作</p>
<p>查询一次和查询多次，在数据不变的情况下，查询结果是一样的，select是天然的幂等操作。</p>
<p>2. 删除操作</p>
<p>删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果多个)。</p>
<p>3.唯一索引，防止新增脏数据</p>
<p>比如：支付宝的资金账户，支付宝也有用户账户，每个用户只能有一个资金账户，怎么防止给用户创建资金账户多个，那么给资金账户表中的用户ID加唯一索引，所以一个用户新增成功一个资金账户记录。</p>
<p>要点：唯一索引或唯一组合索引来防止新增数据存在脏数据 （当表存在唯一索引，并发时新增报错时，再查询一次就可以了，数据应该已经存在了，返回结果即可）。</p>
<p>4. token机制，防止页面重复提交</p>
<p>业务要求：页面的数据只能被点击提交一次；</p>
<p>发生原因：由于重复点击或者网络重发，或者nginx重发等情况会导致数据被重复提交。</p>
<p>解决办法：</p>
<p>集群环境：采用token加redis（redis单线程的，处理需要排队）</p>
<p>单JVM环境：采用token加redis或token加jvm内存</p>
<p>处理流程：</p>
<p>1. 数据提交前要向服务的申请token，token放到redis或jvm内存，token有效时间</p>
<p>2. 提交后后台校验token，同时删除token，生成新的token返回</p>
<p>token特点： 要申请，一次有效性，可以限流</p>
<p>注意：redis要用删除操作来判断token，删除成功代表token校验通过，如果用select+delete来校验token，存在并发问题，不建议使用</p>
<p>5. 悲观锁</p>
<p>获取数据的时候加锁获取</p>
<p>select * from table_xxx where id='xxx' for update;</p>
<p>注意：id字段一定是主键或者唯一索引，不然是锁表，会出事的。</p>
<p>悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用</p>
<figure data-type="image" tabindex="1"><img src="null" alt=""></figure>
<p>6. 乐观锁</p>
<p>乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。</p>
<p>乐观锁的实现方式多种多样可以通过version或者其他状态条件：</p>
<p>1. 通过版本号实现</p>
<p>update table_xxx set name=#name#,version=version+1 where version=#version#</p>
<p>2. 通过条件限制</p>
<p>update table_xxx set avai_amount=avai_amount-#subAmount# where avai_amount-#subAmount# &gt;= 0</p>
<p>要求：quality-#subQuality# &gt;= ，这个情景适合不用版本号，只更新是做数据安全校验，适合库存模型，扣份额和回滚份额，性能更高。</p>
<p>注意：乐观锁的更新操作，最好用主键或者唯一索引来更新,这样是行锁，否则更新时会锁表，上面两个sql改成下面的两个更好。</p>
<p>update table_xxx set name=#name#,version=version+1 where id=#id# and version=#version#</p>
<p>update table_xxx set avai_amount=avai_amount-#subAmount# where id=#id# and avai_amount-#subAmount# &gt;= 0</p>
<p>7. 分布式锁</p>
<p>还是拿插入数据的例子，如果是分布是系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定，这时候可以引入分布式锁，通过第三方的系统(redis或zookeeper)，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁，这样其实是把多线程并发的锁的思路，引入多多个系统，也就是分布式系统中得解决思路。</p>
<p>要点：某个长流程处理过程要求不能并发执行，可以在流程执行之前根据某个标志(用户ID+后缀等)获取分布式锁，其他流程执行时获取锁就会失败，也就是同一时间该流程只能有一个能执行成功，执行完成后，释放分布式锁(分布式锁要第三方系统提供)。</p>
<p>8. select + insert</p>
<p>并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了。</p>
<p>注意：核心高并发流程不要用这种方法。</p>
<p>9. 状态机幂等</p>
<p>在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机(状态变更图)，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机，这时候，如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。</p>
<p>注意：订单等单据类业务，存在很长的状态流转，一定要深刻理解状态机，对业务系统设计能力提高有很大帮助。</p>
<p>10. 对外提供接口的api如何保证幂等</p>
<p>如银联提供的付款接口：需要接入商户提交付款请求时附带：source来源，seq序列号</p>
<p>source+seq在数据库里面做唯一索引，防止多次付款，(并发时，只能处理一个请求)。</p>
<p>重点：</p>
<p>对外提供接口为了支持幂等调用，接口有两个字段必须传，一个是来源source，一个是来源方序列号seq，这个两个字段在提供方系统里面做联合唯一索引，这样当第三方调用时，先在本方系统里面查询一下，是否已经处理过，返回相应处理结果；没有处理过，进行相应处理，返回结果。注意，为了幂等友好，一定要先查询一下，是否处理过该笔业务，不查询直接插入业务系统，会报错，但实际已经处理了。</p>
<p>最后总结：</p>
<p>幂等性应该是合格程序员的一个基因，在设计系统时，是首要考虑的问题，尤其是在像第三方支付平台，银行，互联网金融公司等涉及的网上资金系统，既要高效，数据也要准确，所以不能出现多扣款，多打款等问题，这样会很难处理，并会大大降低用户体验。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UUID]]></title>
        <id>https://zhch602.github.io/post/uuid</id>
        <link href="https://zhch602.github.io/post/uuid">
        </link>
        <updated>2018-05-06T08:13:22.000Z</updated>
        <content type="html"><![CDATA[<p>首先，即便是虚拟机的话MAC地址也是不一样的。另外你说的统一时间还是个宏观的概念，这个仅仅是决定了UUID生产串中的某一部分相同而已，因为为了保证UUID的唯一性，规范定义了包括网卡MAC地址、时间戳、名字空间（Namespace）、随机或伪随机数、时序等元素。<br>
当然，你要说UUID是不是绝对的不会出现重复的，这个也不能这样说的（我下面会提到）。</p>
<p><strong>UUID具有以下涵义：</strong></p>
<p><strong>经由一定的算法机器生成</strong><br>
为了保证UUID的唯一性，规范定义了包括网卡MAC地址、时间戳、名字空间（Namespace）、随机或伪随机数、时序等元素，以及从这些元素生成UUID的算法。UUID的复杂特性在保证了其唯一性的同时，意味着只能由计算机生成。</p>
<p><strong>非人工指定，非人工识别</strong><br>
UUID是不能人工指定的，除非你冒着UUID重复的风险。UUID的复杂性决定了“一般人“不能直接从一个UUID知道哪个对象和它关联。</p>
<p><strong>在特定的范围内重复的可能性极小</strong><br>
UUID的生成规范定义的算法主要目的就是要保证其唯一性。但这个唯一性是有限的，只在特定的范围内才能得到保证，这和UUID的类型有关（参见UUID的版本）。</p>
<p><strong>UUID的版本</strong>UUID具有多个版本，每个版本的算法不同，应用范围也不同。<br>
首先是一个特例－－Nil UUID－－通常我们不会用到它，它是由全为0的数字组成，如下：<br>
00000000-0000-0000-0000-000000000000</p>
<p><strong>UUID Version 1：基于时间的UUID</strong><br>
基于时间的UUID通过计算当前时间戳、随机数和机器MAC地址得到。由于在算法中使用了MAC地址，这个版本的UUID可以保证在全球范围的唯一性。但与此同时，使用MAC地址会带来安全性问题，这就是这个版本UUID受到批评的地方。如果应用只是在局域网中使用，也可以使用退化的算法，以IP地址来代替MAC地址－－Java的UUID往往是这样实现的（当然也考虑了获取MAC的难度）。</p>
<p><strong>UUID Version 2：DCE安全的UUID</strong><br>
DCE（Distributed Computing Environment）安全的UUID和基于时间的UUID算法相同，但会把时间戳的前4位置换为POSIX的UID或GID。这个版本的UUID在实际中较少用到。</p>
<p><strong>UUID Version 3：基于名字的UUID（MD5）</strong><br>
基于名字的UUID通过计算名字和名字空间的MD5散列值得到。这个版本的UUID保证了：相同名字空间中不同名字生成的UUID的唯一性；不同名字空间中的UUID的唯一性；相同名字空间中相同名字的UUID重复生成是相同的。</p>
<p><strong>UUID Version 4：随机UUID</strong><br>
根据随机数，或者伪随机数生成UUID。这种UUID产生重复的概率是可以计算出来的，但随机的东西就像是买彩票：你指望它发财是不可能的，但狗屎运通常会在不经意中到来。</p>
<p><strong>UUID Version 5：基于名字的UUID（SHA1）</strong><br>
和版本3的UUID算法类似，只是散列值计算使用SHA1（Secure Hash Algorithm 1）算法。</p>
<p><strong>UUID的应用</strong>从UUID的不同版本可以看出，<br>
Version 1/2适合应用于分布式计算环境下，具有高度的唯一性；<br>
Version 3/5适合于一定范围内名字唯一，且需要或可能会重复生成UUID的环境下；<br>
至于Version 4，个人的建议是最好不用（虽然它是最简单最方便的）。<br>
通常我们建议使用UUID来标识对象或持久化数据，但以下情况最好不使用UUID：<br>
映射类型的对象。比如只有代码及名称的代码表。<br>
人工维护的非系统生成对象。比如系统中的部分基础数据。<br>
对于具有名称不可重复的自然特性的对象，最好使用Version 3/5的UUID。比如系统中的用户。如果用户的UUID是Version 1的，如果你不小心删除了再重建用户，你会发现人还是那个人，用户已经不是那个用户了。（虽然标记为删除状态也是一种解决方案，但会带来实现上的复杂性。）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySql查询性能优化]]></title>
        <id>https://zhch602.github.io/post/mysql-cha-xun-xing-neng-you-hua</id>
        <link href="https://zhch602.github.io/post/mysql-cha-xun-xing-neng-you-hua">
        </link>
        <updated>2018-04-01T06:52:59.000Z</updated>
        <content type="html"><![CDATA[<h2 id="避免向数据库请求不需要的数据">避免向数据库请求不需要的数据</h2>
<p>在访问数据库时，应该只请求需要的行和列。请求多余的行和列会消耗MySql服务器的CPU和内存资源，并增加网络开销。<br>
例如在处理分页时，应该使用LIMIT限制MySql只返回一页的数据，而不是向应用程序返回全部数据后，再由应用程序过滤不需要的行。<br>
当一行数据被多次使用时可以考虑将数据行缓存起来，避免每次使用都要到MySql查询。<br>
避免使用SELECT *这种方式进行查询，应该只返回需要的列。</p>
<h2 id="查询数据的方式">查询数据的方式</h2>
<p>查询数据的方式有全表扫描、索引扫描、范围扫描、唯一索引查询、常数引用等。这些查询方式，速度从慢到快，扫描的行数也是从多到少。可以通过EXPLAIN语句中的type列反应查询采用的是哪种方式。<br>
通常可以通过添加合适的索引改善查询数据的方式，使其尽可能减少扫描的数据行，加快查询速度。<br>
例如，当发现查询需要扫描大量的数据行但只返回少数的行，那么可以考虑使用覆盖索引，即把所有需要用到的列都放到索引中。这样存储引擎无须回表获取对应行就可以返回结果了。</p>
<h2 id="分解大的查询">分解大的查询</h2>
<p>可以将一个大查询切分成多个小查询执行，每个小查询只完成整个查询任务的一小部分，每次只返回一小部分结果<br>
删除旧的数据是一个很好的例子。如果只用一条语句一次性执行一个大的删除操作，则可能需要一次锁住很多数据，占满整个事务日志，耗尽系统资源、阻塞很多小的但重要的查询。将一个大的删除操作分解成多个较小的删除操作可以将服务器上原本一次性的压力分散到多次操作上，尽可能小地影响MySql性能，减少删除时锁的等待时间。同时也减少了MySql主从复制的延迟。<br>
另一个例子是分解关联查询，即对每个要关联的表进行单表查询，然后将结果在应用程序中进行关联。下面的这个查询：</p>
<pre><code>SELECT * FROM tag
    JOIN tag_post ON tag_post.tag_id=tag.id
    JOIN post ON tag_post.post_id=post.id
WHERE tag.tag = 'mysql';
</code></pre>
<p>可以分解成下面这些查询来代替：</p>
<pre><code>SELECT * FROM tag WHERE tag = 'mysql';
SELECT * FROM tag_post WHERE tag_id = 1234;
SELECT * FROM post WHERE post.id in (123,456,567,9098,8904);
</code></pre>
<p>将一个关联查询拆解成多个单表查询有如下有点：</p>
<ol>
<li>让缓存的效率更高。如果缓存的是关联查询的结果，那么其中的一个表发生变化，整个缓存就失效了。而拆分后，如果只是某个表很少的改动，并不会破坏所有的缓存。</li>
<li>可以减少锁的竞争</li>
<li>更容易对数据库进行拆分，更容易做到高性能和可扩展。</li>
<li>查询本身的效率也有可能会有所提升。例如上面用IN()代替关联查询比随机的关联更加高效。</li>
</ol>
<h2 id="优化min和max">优化MIN()和MAX()</h2>
<p>添加索引可以优化MIN()和MAX()表达式。例如，要找到某一列的最小值，只需要查询对应B-Tree索引的最左端的记录即可。类似的，如果要查询列中的最大值，也只需要读取B-Tree索引的最后一条记录。对于这种查询，EXPLAIN中可以看到&quot;Select tables optimized away&quot;,表示优化器已经从执行计划中移除了该表，并以一个常数取而代之。</p>
<h2 id="用in取代or">用IN()取代OR</h2>
<p>在MySql中，IN()先将自己列表中的数据进行排序，然后通过二分查找的方式确定列的值是否在IN()的列表中，这个时间复杂度是O(logn)。如果换成OR操作，则时间复杂度是O(n)。所以，对于IN()的列表中有大量取值的时候，用IN()替换OR操作将会更快。</p>
<h2 id="优化关联查询">优化关联查询</h2>
<p>在MySql中，任何一个查询都可以看成是一个关联查询，即使只有一个表的查询也是如此。<br>
MySql对任何关联都执行嵌套循环的关联操作，例如对于下面的SQL语句：</p>
<pre><code>SELECT tbl1.col1,tbl2.col2
FROM tbl1 INNER JOIN tbl2 USING(col3)
WHERE tbl1.col1 IN(5,6);
</code></pre>
<p>下面的伪代码表示MySql将如何执行这个查询：</p>
<pre><code>//先从第一个表中取出符合条件的所有行
out_iter = iterator over tbl1 where col1 IN(5,6)
outer_row = out_iter.next
//在while循环中遍历第一个表结果集的每一行
while outer_row
    //对于第一个表结果集中的每一行，在第二个表中找出符合条件的所有行
    inner_iter = iterator over tbl2 where col3 = outer_row.col3
    inner_row = inner_iter.next
    while inner_row
        //将第一个表的结果列和第二个表的结果列拼装在一起作为结果输出
        output[outer_row.col1, inner_row.col2]
        inner_row = inner_iter.next
    end
    //回溯，再根据第一个表结果集的下一行，继续上面的过程
    outer_row = outer_iter.next
end
</code></pre>
<p>对于单表查询，那么只需要完成上面外层的基本操作。<br>
优化关联查询，要确保ON或者USING子句中的列上有索引，并且在建立索引时需要考虑到关联的顺序。通常来说，只需要在关联顺序中的第二个表的相应列上创建索引。例如，当表A和表B用列c关联的时候，假设关联的顺序是B、A，那么就不需要在B表的c列上建立索引。没有用到的索引只会带来额外的负担。<br>
此外，确保任何的GROUP BY和ORDER BY中的表达式只涉及到一个表中的列，这样才能使用索引来优化这个过程。</p>
<h2 id="临时表的概念">临时表的概念</h2>
<p>上面提到在MySql中，任何一个查询实质上都是一个关联查询。那么对于子查询或UNION查询是如何实现关联操作的呢。<br>
对于UNION查询，MySql先将每一个单表查询结果放到一个临时表中，然后再重新读出临时表数据来完成UNION查询。MySql读取结果临时表和普通表一样，也是采用的关联方式。<br>
当遇到子查询时，先执行子查询并将结果放到一个临时表中，然后再将这个临时表当做一个普通表对待。<br>
MySql的临时表是没有任何索引的，在编写复杂的子查询和关联查询的时候需要注意这一点。<br>
临时表也叫派生表。</p>
<h2 id="排序优化">排序优化</h2>
<p>应该尽量让MySql使用索引进行排序。当不能使用索引生成排序结果的时候，MySql需要自己进行排序。如果数据量小于“排序缓冲区”的大小，则MySql使用内存进行“快速排序”操作。如果数据量太大超过“排序缓冲区”的大小，那么MySql只能采用文件排序，而文件排序的算法非常复杂，会消耗很多资源。<br>
无论如何排序都是一个成本很高的操作，所以从性能角度考虑，应尽可能避免排序。所以让MySql根据索引构造排序结果非常的重要。</p>
<h2 id="子查询优化">子查询优化</h2>
<p>MySql的子查询实现的非常糟糕。最糟糕的一类查询是WHERE条件中包含IN()的子查询语句。<br>
应该尽可能用关联替换子查询，可以提高查询效率。</p>
<h2 id="优化count查询">优化COUNT()查询</h2>
<p>COUNT()有两个不同的作用：</p>
<ol>
<li>统计某个列值的数量，即统计某列值不为NULL的个数。</li>
<li>统计行数。</li>
</ol>
<p>当使用COUNT(*)时，统计的是行数，它会忽略所有的列而直接统计所有的行数。而在括号中指定了一个列的话，则统计的是这个列上值不为NULL的个数。<br>
可以考虑使用索引覆盖扫描或增加汇总表对COUNT()进行优化。</p>
<h2 id="优化limit分页">优化LIMIT分页</h2>
<p>处理分页会使用到LIMIT，当翻页到非常靠后的页面的时候，偏移量会非常大，这时LIMIT的效率会非常差。例如对于**<em>LIMIT 10000，20</em>**这样的查询，MySql需要查询10020条记录，将前面10000条记录抛弃，只返回最后的20条。这样的代价非常高，如果所有的页面被访问的频率都相同，那么这样的查询平均需要访问半个表的数据。<br>
优化此类分页查询的一个最简单的办法就是尽可能地使用索引覆盖扫描，而不是查询所有的列。然后根据需要与原表做一次关联操作返回所需的列。对于偏移量很大的时候，这样的效率会提升非常大。考虑下面的查询：</p>
<pre><code>SELECT film_id, description FROM sakila.film ORDER BY title LIMIT 50, 5;
</code></pre>
<p>如果这个表非常大，那么这个查询最好改写成下面的这样子：</p>
<pre><code>SELECT film.film_id, film.description FROM sakila.film
INNER JOIN 
(SELECT film_id FROM sakila.film ORDER BY title LIMIT 50,5) AS lim
USING(film_id);
</code></pre>
<p>注意优化中关联的子查询，因为只查询film_id一个列，数据量小，使得一个内存页可以容纳更多的数据，这让MySQL扫描尽可能少的页面。在获取到所需要的所有行之后再与原表进行关联以获得需要的全部列。<br>
LIMIT的优化问题，其实是OFFSET的问题，它会导致MySql扫描大量不需要的行然后再抛弃掉。可以借助书签的思想记录上次取数据的位置，那么下次就可以直接从该书签记录的位置开始扫描，这样就避免了使用OFFSET。可以把主键当做书签使用，例如下面的查询：</p>
<pre><code>SELECT * FROM sakila.rental ORDER BY rental_id DESC LIMIT 20;
</code></pre>
<p>假设上面的查询返回的是主键为16049到16030的租借记录，那么下一页查询就可以直接从16030这个点开始：</p>
<pre><code>SELECT * FROM sakila.rental WHERE rental_id &lt; 16030
ORDER BY rental_id DESC LIMIT 20;
</code></pre>
<p>该技术的好处是无论翻页到多么后面，其性能都会很好。<br>
此外，也可以用关联到一个冗余表的方式提高LIMIT的性能，冗余表只包含主键列和需要做排序的数据列。</p>
<h2 id="优化union查询">优化UNION查询</h2>
<p>除非确实需要服务器消除重复的行，否则一定要使用UNION ALL。如果没有ALL关键字，MySql会给临时表加上DISTINCT选项，这会导致对整个临时表的数据做唯一性检查。这样做的代价非常高。</p>
]]></content>
    </entry>
</feed>